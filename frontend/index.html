<script>
  let map;
  let mainRouteLayer = null;
  let altRouteLayer = null;
  let bridgeMarkers = [];
  let lastRouteData = null;

  function initMap() {
    map = L.map("map").setView([53.7, -1.6], 11);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);
  }

  function setStatus(text, variant) {
    const badge = document.getElementById("route-status");
    if (!badge) return;

    badge.textContent = text;

    badge.classList.remove("status-idle", "status-searching", "status-ready", "status-error");

    switch (variant) {
      case "searching":
        badge.classList.add("status-searching");
        break;
      case "ready":
        badge.classList.add("status-ready");
        break;
      case "error":
        badge.classList.add("status-error");
        break;
      default:
        badge.classList.add("status-idle");
    }
  }

  async function generateRoute(ev) {
    if (ev) ev.preventDefault();

    const start = document.getElementById("start-postcode").value.trim();
    const dest = document.getElementById("dest-postcode").value.trim();
    const heightStr = document.getElementById("vehicle-height").value.trim();
    const avoidLow = document.getElementById("avoid-low-bridges").checked;

    if (!start || !dest || !heightStr) {
      alert("Please enter start, destination and vehicle height.");
      return;
    }

    const height = parseFloat(heightStr);
    if (Number.isNaN(height) || height <= 0) {
      alert("Vehicle height must be a positive number in metres.");
      return;
    }

    setStatus("Searching route…", "searching");

    try {
      const resp = await fetch("https://routesafe-navigatorv2.onrender.com/api/route", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          start_postcode: start,
          dest_postcode: dest,
          vehicle_height_m: height,
          avoid_low_bridges: avoidLow,
        }),
      });

      if (!resp.ok) {
        console.error("API error:", resp.status, await resp.text());
        alert("Sorry – couldn’t generate a route. Please try again.");
        setStatus("Error", "error");
        return;
      }

      const data = await resp.json();
      lastRouteData = data;

      updateSummary(data);
      updateBridgeCard(data);
      drawRouteOnMap(data);

      setStatus("Route ready", "ready");
    } catch (err) {
      console.error(err);
      alert("Network error while contacting the navigator service.");
      setStatus("Error", "error");
    }
  }

  function updateSummary(data) {
    const distanceEl = document.getElementById("summary-distance");
    const timeEl = document.getElementById("summary-time");
    const riskEl = document.getElementById("summary-bridge-risk");
    const nearestEl = document.getElementById("summary-nearest-bridge");
    const riskBadge = document.getElementById("summary-risk-badge");

    if (!data || !data.metrics) return;

    const km = data.metrics.distance_km ?? null;
    const mins = data.metrics.duration_min ?? null;
    const risk = data.bridge_result?.risk_level ?? "Unknown";
    const nearestHeight = data.bridge_result?.nearest_bridge_height_m ?? null;
    const nearestDist = data.bridge_result?.nearest_bridge_distance_m ?? null;

    distanceEl.textContent = km != null ? `${km.toFixed(1)} km` : "-";
    timeEl.textContent = mins != null ? `${Math.round(mins)} mins` : "-";
    riskEl.textContent = risk;

    if (nearestHeight != null && nearestDist != null) {
      nearestEl.textContent = `${nearestHeight.toFixed(2)} m · ${Math.round(nearestDist)} m`;
    } else {
      nearestEl.textContent = "-";
    }

    riskBadge.textContent = risk === "Conflict" || risk === "HIGH" ? "High" : "Low";

    riskBadge.classList.remove("risk-low", "risk-high");
    if (risk === "Conflict" || risk === "HIGH") {
      riskBadge.classList.add("risk-high");
    } else {
      riskBadge.classList.add("risk-low");
    }
  }

  function updateBridgeCard(data) {
    const riskText = document.getElementById("bridge-risk-text");
    const nearestText = document.getElementById("bridge-nearest-text");

    if (!data || !data.bridge_result) {
      riskText.textContent = "-";
      nearestText.textContent = "-";
      return;
    }

    const br = data.bridge_result;
    riskText.textContent = br.risk_level ?? "-";

    if (br.nearest_bridge_height_m != null && br.nearest_bridge_distance_m != null) {
      nearestText.textContent = `${br.nearest_bridge_height_m.toFixed(2)} m · ${Math.round(
        br.nearest_bridge_distance_m
      )} m`;
    } else {
      nearestText.textContent = "-";
    }
  }

  function clearMap() {
    if (!map) return;

    if (mainRouteLayer) {
      map.removeLayer(mainRouteLayer);
      mainRouteLayer = null;
    }
    if (altRouteLayer) {
      map.removeLayer(altRouteLayer);
      altRouteLayer = null;
    }
    bridgeMarkers.forEach((m) => map.removeLayer(m));
    bridgeMarkers = [];
  }

  function drawRouteOnMap(data) {
    if (!map || !data) return;

    clearMap();

    const mainCoords = data.main_route?.coords || [];
    const altCoords = data.alt_route?.coords || null;
    const risk = data.bridge_result?.risk_level || "LOW";
    const avoidLow = document.getElementById("avoid-low-bridges").checked;

    // Decide which route is the "selected" (safe) one
    let selectedCoords = mainCoords;
    let secondaryCoords = altCoords;
    let selectedType = "main";

    if (
      (risk === "Conflict" || risk === "HIGH") &&
      avoidLow &&
      altCoords &&
      altCoords.length > 1
    ) {
      selectedCoords = altCoords;
      secondaryCoords = mainCoords;
      selectedType = "alt";
    }

    // Draw selected route – thick solid line
    if (selectedCoords && selectedCoords.length > 1) {
      mainRouteLayer = L.polyline(selectedCoords, { weight: 6 }).addTo(map);
      map.fitBounds(mainRouteLayer.getBounds(), { padding: [20, 20] });
    }

    // Draw the "other" route – thinner dashed line
    if (secondaryCoords && secondaryCoords.length > 1) {
      altRouteLayer = L.polyline(secondaryCoords, { weight: 4, dashArray: "6,4" }).addTo(map);
    }

    // Low-bridge markers (nearest only for now)
    if (data.bridge_result?.nearest_bridge_lat && data.bridge_result?.nearest_bridge_lon) {
      const marker = L.circleMarker(
        [data.bridge_result.nearest_bridge_lat, data.bridge_result.nearest_bridge_lon],
        { radius: 6 }
      ).addTo(map);
      bridgeMarkers.push(marker);
    }

    // Store what we decided so the Google Maps button can use it
    lastRouteData = {
      ...data,
      _selected_type: selectedType,
    };
  }

  function openInGoogleMaps() {
    if (!lastRouteData) return;

    const risk = lastRouteData.bridge_result?.risk_level || "LOW";
    const avoidLow = document.getElementById("avoid-low-bridges").checked;

    let coords = lastRouteData.main_route.coords;

    // If there is a conflict + avoid low bridges + alt route ⇒ use alt route
    if (
      (risk === "Conflict" || risk === "HIGH") &&
      avoidLow &&
      lastRouteData.alt_route &&
      lastRouteData.alt_route.coords &&
      lastRouteData.alt_route.coords.length > 1
    ) {
      coords = lastRouteData.alt_route.coords;
    }

    if (!coords || coords.length < 2) return;

    const origin = coords[0];
    const dest = coords[coords.length - 1];

    const originStr = `${origin[0]},${origin[1]}`;
    const destStr = `${dest[0]},${dest[1]}`;

    // Sample intermediate points as waypoints (max 8)
    const maxWaypoints = 8;
    const step = Math.max(1, Math.floor(coords.length / (maxWaypoints + 1)));
    const waypoints = [];

    for (let i = step; i < coords.length - 1 && waypoints.length < maxWaypoints; i += step) {
      const [lat, lon] = coords[i];
      waypoints.push(`${lat},${lon}`);
    }

    let url = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(
      originStr
    )}&destination=${encodeURIComponent(destStr)}`;

    if (waypoints.length) {
      url += `&waypoints=${encodeURIComponent(waypoints.join("|"))}`;
    }

    window.open(url, "_blank");
  }

  document.addEventListener("DOMContentLoaded", () => {
    initMap();

    const form = document.getElementById("route-form");
    if (form) {
      form.addEventListener("submit", generateRoute);
    }

    const btn = document.getElementById("generate-route-btn");
    if (btn) {
      btn.addEventListener("click", generateRoute);
    }

    const gmapsBtn = document.getElementById("open-google-maps-btn");
    if (gmapsBtn) {
      gmapsBtn.addEventListener("click", openInGoogleMaps);
    }
  });
</script>